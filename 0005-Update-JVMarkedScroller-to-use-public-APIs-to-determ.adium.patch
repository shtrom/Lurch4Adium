From d707680f2f662a2606294953976db0b5c63dee6b Mon Sep 17 00:00:00 2001
From: ? <kcochran@trolans.net>
Date: Sat, 19 Oct 2019 17:36:48 -0700
Subject: [PATCH] Update JVMarkedScroller to use public APIs to determine
 scroller direction

---
 .../Source/JVMarkedScroller.h                 |  3 ++
 .../Source/JVMarkedScroller.m                 | 34 +++++++++++--------
 2 files changed, 22 insertions(+), 15 deletions(-)

diff --git a/Frameworks/AIUtilities Framework/Source/JVMarkedScroller.h b/Frameworks/AIUtilities Framework/Source/JVMarkedScroller.h
index fd67c9e9a..f41a6d40c 100644
--- a/Frameworks/AIUtilities Framework/Source/JVMarkedScroller.h	
+++ b/Frameworks/AIUtilities Framework/Source/JVMarkedScroller.h	
@@ -23,6 +23,9 @@
 	NSUInteger _currentMark;
 	BOOL _jumpingToMark;
 }
+
+@property (readonly) BOOL isHorizontalScroller;
+
 - (void) setLocationOfCurrentMark:(NSUInteger) location;
 - (unsigned long long) locationOfCurrentMark;
 
diff --git a/Frameworks/AIUtilities Framework/Source/JVMarkedScroller.m b/Frameworks/AIUtilities Framework/Source/JVMarkedScroller.m
index 3f2dbd2b4..b0cf28db2 100644
--- a/Frameworks/AIUtilities Framework/Source/JVMarkedScroller.m	
+++ b/Frameworks/AIUtilities Framework/Source/JVMarkedScroller.m	
@@ -43,6 +43,10 @@ __unsafe_unretained	NSColor *color;
 
 #pragma mark -
 
+- (BOOL)isHorizontalScroller {
+    return self.enclosingScrollView.horizontalScroller == self;
+}
+
 + (BOOL)isCompatibleWithOverlayScrollers {
     return self == [JVMarkedScroller class];
 }
@@ -55,10 +59,10 @@ __unsafe_unretained	NSColor *color;
 	CGFloat width =  [[self class] scrollerWidthForControlSize:[self controlSize] scrollerStyle:[self scrollerStyle]];
 	
 	CGFloat scale = [self scaleToContentView];
-	[transform scaleXBy:( sFlags.isHoriz ? scale : 1.f ) yBy:( sFlags.isHoriz ? 1.f : scale )];
+	[transform scaleXBy:( self.isHorizontalScroller ? scale : 1.f ) yBy:( self.isHorizontalScroller ? 1.f : scale )];
 	
 	CGFloat offset = [self rectForPart:NSScrollerKnobSlot].origin.y;
-	[transform translateXBy:( sFlags.isHoriz ? offset / scale : 0.f ) yBy:( sFlags.isHoriz ? 0.f : offset / scale )];
+	[transform translateXBy:( self.isHorizontalScroller ? offset / scale : 0.f ) yBy:( self.isHorizontalScroller ? 0.f : offset / scale )];
 	
 	NSBezierPath *shades = [NSBezierPath bezierPath];
 	NSEnumerator *enumerator = [_shades objectEnumerator];
@@ -70,7 +74,7 @@ __unsafe_unretained	NSColor *color;
 		NSUInteger stop = [stopNum unsignedIntegerValue];
 		
 		NSRect shadesRect = NSZeroRect;
-		if( sFlags.isHoriz ) shadesRect = NSMakeRect( start, 0.f, ( stop - start ), width );
+		if( self.isHorizontalScroller ) shadesRect = NSMakeRect( start, 0.f, ( stop - start ), width );
 		else shadesRect = NSMakeRect( 0.f, start, width, ( stop - start ) );
 		
 		shadesRect.origin = [transform transformPoint:shadesRect.origin];
@@ -84,7 +88,7 @@ __unsafe_unretained	NSColor *color;
 		NSUInteger start = [[_shades lastObject] unsignedIntegerValue];
 		CGFloat stop = [self contentViewLength];
 		
-		if( sFlags.isHoriz ) shadesRect = NSMakeRect( start, 0.f, ( stop - start ), width );
+		if( self.isHorizontalScroller ) shadesRect = NSMakeRect( start, 0.f, ( stop - start ), width );
 		else shadesRect = NSMakeRect( 0.f, start, width, ( stop - start ) );
 		
 		shadesRect.origin = [transform transformPoint:shadesRect.origin];
@@ -124,17 +128,17 @@ __unsafe_unretained	NSColor *color;
 			foundNext = YES;
 		}
 		
-		NSPoint point = NSMakePoint( ( sFlags.isHoriz ? value : 0 ), ( sFlags.isHoriz ? 0 : value ) );
+		NSPoint point = NSMakePoint( ( self.isHorizontalScroller ? value : 0 ), ( self.isHorizontalScroller ? 0 : value ) );
 		point = [transform transformPoint:point];
-		point.x = ( sFlags.isHoriz ? AIround( point.x ) + 0.5f : point.x );
-		point.y = ( sFlags.isHoriz ? point.y : AIround( point.y ) + 0.5f );
+		point.x = ( self.isHorizontalScroller ? AIround( point.x ) + 0.5f : point.x );
+		point.y = ( self.isHorizontalScroller ? point.y : AIround( point.y ) + 0.5f );
 		
 		if( ! NSPointInRect( point, knobRect ) ) {
 			if( mark.color ) {
 				NSBezierPath *line = [NSBezierPath bezierPath];
 				[line moveToPoint:point];
 				
-				point = NSMakePoint( ( sFlags.isHoriz ? 0.f : width ), ( sFlags.isHoriz ? width : 0.f ) );
+				point = NSMakePoint( ( self.isHorizontalScroller ? 0.f : width ), ( self.isHorizontalScroller ? width : 0.f ) );
 				[line relativeLineToPoint:point];
 				[line setLineWidth:2];
 				[lineArray addObject:mark.color];
@@ -142,7 +146,7 @@ __unsafe_unretained	NSColor *color;
 			} else {
 				[lines moveToPoint:point];
 				
-				point = NSMakePoint( ( sFlags.isHoriz ? 0.f : width ), ( sFlags.isHoriz ? width : 0.f ) );
+				point = NSMakePoint( ( self.isHorizontalScroller ? 0.f : width ), ( self.isHorizontalScroller ? width : 0.f ) );
 				[lines relativeLineToPoint:point];
 			}
 		}
@@ -194,7 +198,7 @@ __unsafe_unretained	NSColor *color;
 	[item setTarget:self];
 	[menu addItem:item];
 	
-	if( sFlags.isHoriz ) {
+	if( self.isHorizontalScroller ) {
 		item = [[NSMenuItem alloc] initWithTitle:AILocalizedStringFromTableInBundle( @"Clear Marks from Here Left", nil, [NSBundle bundleWithIdentifier:AIUTILITIES_BUNDLE_ID], "clear marks from here left contextual menu") 
 										   action:@selector( clearMarksHereLess: ) 
 									keyEquivalent:@""];
@@ -280,7 +284,7 @@ __unsafe_unretained	NSColor *color;
 	NSPoint where = [self convertPoint:[event locationInWindow] fromView:nil];
 	NSRect slotRect = [self rectForPart:NSScrollerKnobSlot];
 	CGFloat scale = [self scaleToContentView];
-	[self removeMarksLessThan:( ( sFlags.isHoriz ? where.x - NSMinX( slotRect ) : where.y - NSMinY( slotRect ) ) / scale )];
+	[self removeMarksLessThan:( ( self.isHorizontalScroller ? where.x - NSMinX( slotRect ) : where.y - NSMinY( slotRect ) ) / scale )];
 }
 
 - (IBAction) clearMarksHereGreater:(id) sender {
@@ -288,7 +292,7 @@ __unsafe_unretained	NSColor *color;
 	NSPoint where = [self convertPoint:[event locationInWindow] fromView:nil];
 	NSRect slotRect = [self rectForPart:NSScrollerKnobSlot];
 	CGFloat scale = [self scaleToContentView];
-	[self removeMarksGreaterThan:( ( sFlags.isHoriz ? where.x - NSMinX( slotRect ) : where.y - NSMinY( slotRect ) ) / scale )];
+	[self removeMarksGreaterThan:( ( self.isHorizontalScroller ? where.x - NSMinX( slotRect ) : where.y - NSMinY( slotRect ) ) / scale )];
 }
 
 #pragma mark -
@@ -578,18 +582,18 @@ __unsafe_unretained	NSColor *color;
 #pragma mark -
 
 - (CGFloat) contentViewLength {
-	if( sFlags.isHoriz ) return ( NSWidth( [self frame] ) / [self knobProportion] );
+	if( self.isHorizontalScroller ) return ( NSWidth( [self frame] ) / [self knobProportion] );
 	else return ( NSHeight( [self frame] ) / [self knobProportion] );
 }
 
 - (CGFloat) scaleToContentView {
-	if( sFlags.isHoriz ) return NSWidth( [self rectForPart:NSScrollerKnobSlot] ) / NSWidth( [[(NSScrollView *)[self superview] contentView] documentRect] );
+	if( self.isHorizontalScroller ) return NSWidth( [self rectForPart:NSScrollerKnobSlot] ) / NSWidth( [[(NSScrollView *)[self superview] contentView] documentRect] );
 	else return NSHeight( [self rectForPart:NSScrollerKnobSlot] ) / NSHeight( [[(NSScrollView *)[self superview] contentView] documentRect] );
 }
 
 - (CGFloat) shiftAmountToCenterAlign {
 	CGFloat scale = [self scaleToContentView];
-	if( sFlags.isHoriz ) return ( ( NSWidth( [self rectForPart:NSScrollerKnobSlot] ) * [self knobProportion] ) / 2.f ) / scale;
+	if( self.isHorizontalScroller ) return ( ( NSWidth( [self rectForPart:NSScrollerKnobSlot] ) * [self knobProportion] ) / 2.f ) / scale;
 	else return ( ( NSHeight( [self rectForPart:NSScrollerKnobSlot] ) * [self knobProportion] ) / 2.f ) / scale;
 }
 @end
-- 
2.25.0

